<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Library</name>
    </assembly>
    <members>
        <member name="T:ClassLibrary.Facade">
            <summary>
            La clase  <c>Facade</c> proporciona una interfaz simplificada para interactuar con el juego, permitiendo a los jugadores seleccionar
            Pokémon, mostrar movimientos, activar ataques y consultar la salud de los Pokémon. Aplica el Patrón de Diseño Facade,
            que oculta la complejidad del sistema y simplifica la interacción con múltiples subsistemas, mejorando la usabilidad.
            Esta clase sigue el Principio de Responsabilidad Única (SRP) al concentrar la lógica de interacción en un solo lugar,
            lo que facilita el mantenimiento y la evolución del sistema. Además, respeta el Principio de Inversión de Dependencias (DIP)
            al depender de abstracciones, permitiendo una mayor flexibilidad y una mejor capacidad de prueba. Esta estructura permite a los
            desarrolladores y jugadores interactuar con el juego de manera más intuitiva, minimizando la necesidad de conocer la
            implementación interna.
            </summary>
        </member>
        <member name="P:ClassLibrary.Facade.Instance">
            <summary>
            Obtiene la única instancia de la clase <see cref="T:ClassLibrary.Facade"/>.
            </summary>
        </member>
        <member name="M:ClassLibrary.Facade.Reset">
            <summary>
            Inicializa este singleton. Es necesario solo en los tests.
            </summary>
        </member>
        <member name="M:ClassLibrary.Facade.ShowMoves(System.String)">
            <summary>
            Muestra los movimientos disponibles de los Pokémon del jugador seleccionado.
            </summary>
            <param name="playerDisplayName">El nombre del jugador.</param>
            <returns>Una lista de cadenas con los Pokémon y sus movimientos.</returns>
        </member>
        <member name="M:ClassLibrary.Facade.ChoosePokemonAndMoveToAttack(System.String,System.String,System.String)">
            <summary>
            Permite a un jugador seleccionar un Pokémon y un movimiento para atacar.
            </summary>
            <param name="playerDisplayName">El nombre del jugador.</param>
            <param name="moveName">El nombre del movimiento a utilizar.</param>
            <param name="pokemonName">El nombre del Pokémon que realizará el ataque.</param>
        </member>
        <member name="M:ClassLibrary.Facade.GetPokemonsHealth(System.String)">
            <summary>
            Obtiene la salud de los Pokémon de un jugador y su oponente, formateada en una cadena.
            </summary>
            <param name="playerDisplayName">El nombre del jugador del cual se obtendrá la salud de los Pokémon.</param>
            <returns>Una cadena que contiene la información de la salud de los Pokémon del jugador y su oponente.</returns>
            <exception cref="T:System.ArgumentException">Se lanza si el jugador o el oponente no se encuentran.</exception>
        </member>
        <member name="M:ClassLibrary.Facade.ChangePokemon(System.String,System.String)">
            <summary>
            Cambia el Pokémon activo del jugador al especificado por <paramref name="newPokemonName"/> y pierde su turno.
            </summary>
            <param name="playerDisplayName">Nombre del jugador que quiere cambiar de Pokémon.</param>
            <param name="newPokemonName">Nombre del nuevo Pokémon a activar.</param>
            <returns>Un mensaje formateado indicando el cambio de Pokémon y la pérdida de turno.</returns>
            <exception cref="T:System.ArgumentException">Se lanza si el jugador no está en la partida o si el Pokémon no está disponible.</exception>
            <exception cref="T:System.ArgumentNullException">Se lanza si <paramref name="playerDisplayName"/> o <paramref name="newPokemonName"/> son nulos o están vacíos.</exception>
        </member>
        <member name="M:ClassLibrary.Facade.AddPlayerToWaitingList(System.String)">
            <summary>
            Agrega un jugador a la lista de espera.
            </summary>
            <param name="displayName">El nombre del jugador.</param>
            <returns>Un mensaje con el resultado.</returns>
        </member>
        <member name="M:ClassLibrary.Facade.RemovePlayerFromWaitingList(System.String)">
            <summary>
            Remueve un jugador de la lista de espera.
            </summary>
            <param name="displayName">El jugador a remover.</param>
            <returns>Un mensaje con el resultado.</returns>
        </member>
        <member name="M:ClassLibrary.Facade.GetAllPlayersWaiting">
            <summary>
            Obtiene la lista de jugadores esperando.
            </summary>
            <returns>Un mensaje con el resultado.</returns>
        </member>
        <member name="M:ClassLibrary.Facade.PlayerIsWaiting(System.String)">
            <summary>
            Determina si un jugador está esperando para jugar.
            </summary>
            <param name="displayName">El jugador.</param>
            <returns>Un mensaje con el resultado.</returns>
        </member>
        <member name="M:ClassLibrary.Facade.StartBattle(System.String,System.String)">
            <summary>
            Crea una batalla entre dos jugadores.
            </summary>
            <param name="playerDisplayName">El primer jugador.</param>
            <param name="opponentDisplayName">El oponente.</param>
            <returns>Un mensaje con el resultado.</returns>
        </member>
        <member name="T:ClassLibrary.Game">
            <summary>
            La clase <c>Game</c> tiene la responsabilidad de conocer a los jugadores y verificar si el juego está activo o ha terminado.
            Esto sigue el principio de responsabilidad única (SRP) ya que su única función es gestionar el estado del juego.
            Además, según el principio de "experto" (Expert), la clase <c>Game</c> es la más adecuada para gestionar estas tareas, 
            ya que contiene toda la información sobre los jugadores y el estado del juego.
            </summary>
        </member>
        <member name="P:ClassLibrary.Game.Player1">
            <summary>
            Propiedad que almacena al jugador 1 del juego.
            La clase <c>Game</c> sigue el principio de "experto" (Expert), ya que tiene la responsabilidad de manejar los jugadores
            y su relación dentro del juego.
            </summary>
        </member>
        <member name="P:ClassLibrary.Game.Player2">
            <summary>
            Propiedad que almacena al jugador 2 del juego.
            Similar a Player1, sigue el principio de "experto" (Expert) porque la clase <c>Game</c> necesita conocer los jugadores
            para controlar el flujo del juego.
            </summary>
        </member>
        <member name="P:ClassLibrary.Game.Turn">
            <summary>
            Instancia de la clase Turn para gestionar el turno actual del juego.
            </summary>
        </member>
        <member name="P:ClassLibrary.Game.TurnPlayer">
            <summary>
            Propiedad que indica el jugador que actualmente tiene el turno.
            </summary>
        </member>
        <member name="P:ClassLibrary.Game.PlayIsOn">
            <summary>
            Propiedad que indica si el juego sigue activo (true) o ha terminado (false).
            Esto también sigue el SRP, ya que la clase <c>Game</c> es la responsable de gestionar el estado del juego, 
            y no otros objetos, respetando el principio de segregación de responsabilidades.
            </summary>
        </member>
        <member name="M:ClassLibrary.Game.#ctor(ClassLibrary.Player,ClassLibrary.Player)">
            <summary>
            Constructor de la clase <c>Game</c>. Inicializa los jugadores y el estado del juego.
            El constructor asigna las propiedades adecuadamente siguiendo el principio de Liskov Substitution Principle (LSP),
            lo cual permite que cualquier clase derivada de <c>Player</c> funcione correctamente en la lógica del juego.
            </summary>
            <param name="player1">El primer jugador.</param>
            <param name="player2">El segundo jugador.</param>
        </member>
        <member name="M:ClassLibrary.Game.CheckIfGameEnds">
            <summary>
            Verifica si el juego debe terminar revisando si todos los Pokémon de alguno de los jugadores tienen 0 puntos de vida.
            Si un jugador pierde todos sus Pokémon, el juego termina y se declara un ganador.
            Este método puede ser fácilmente extendido o modificado con otras reglas de fin de juego, 
            alineado con el principio de Polimorfismo, donde nuevas reglas de finalización pueden ser añadidas sin alterar la estructura básica.
            </summary>
        </member>
        <member name="T:ClassLibrary.GameList">
            <summary>
            Esta clase representa la lista de batallas en curso.
            </summary>
        </member>
        <member name="M:ClassLibrary.GameList.AddGame(ClassLibrary.Player,ClassLibrary.Player)">
            <summary>
            Crea una nueva batalla entre dos jugadores.
            </summary>
            <param name="player1">El primer jugador.</param>
            <param name="player2">El oponente.</param>
            <returns>La batalla creada.</returns>
        </member>
        <member name="M:ClassLibrary.GameList.FindPlayerByDisplayName(System.String)">
            <summary>
            Encuentra un jugador por su nombre para una batalla en curso.
            </summary>
            <param name="displayName">El nombre del jugador.</param>
            <returns>El objeto Player si se encuentra; de lo contrario, null.</returns>
        </member>
        <member name="M:ClassLibrary.Item.ApplyEffect(ClassLibrary.Pokemon)">
            <summary>
            Aplica el efecto del ítem en el Pokémon especificado.
            Este método será sobrescrito por las subclases.
            </summary>
            <param name="pokemon">El Pokémon al que se le aplicará el efecto.</param>
            <returns>Un mensaje con el resultado de aplicar el efecto.</returns>
        </member>
        <member name="P:ClassLibrary.Move.Name">
            <summary>
            Nombre del movimiento. 
            </summary>
        </member>
        <member name="P:ClassLibrary.Move.AttackValue">
            <summary>
            Valor del ataque del movimiento.
            </summary>
        </member>
        <member name="P:ClassLibrary.Move.Accuracy">
            <summary>
            El valor de precisión define la probabilidad de que el ataque se ejecute. 
            </summary>
        </member>
        <member name="M:ClassLibrary.Move.#ctor(System.String,System.Int32,System.Double)">
            <summary>
            Constructor de la clase.
            </summary>
            <param name="name">El nombre del movimiento.</param>
            <param name="attackValue">El valor de ataque del movimiento.</param>
        </member>
        <member name="M:ClassLibrary.Move.ExecuteMove(ClassLibrary.Pokemon,ClassLibrary.Pokemon,System.Double)">
             <summary>
             Método para aplicar el ataque considerando ambos pokemones.
             </summary>
             <param name="attacker">El pokemon que está atacando.</param>
             <param name="target">El pokemon que está siendo atacado.</param>
            
        </member>
        <member name="T:ClassLibrary.MoveBurn">
            <summary>
            La clase <c>MoveSleep</c> tiene la responsabilidad de almacenar y gestionar los valores de ataque, su nombre, y método de ejecución de un movimiento especial.
            Esto sigue el principio de responsabilidad única (SRP) ya que su única función es representar los atributos de un movimiento en el juego.
            </summary>
            
        </member>
        <member name="M:ClassLibrary.MoveBurn.#ctor(System.String,System.Int32,System.Double)">
            <summary>
            Constructor de la clase <c>MoveBurn</c>. Inicializa los valores de nombre, ataque, defensa y curación.
            Esto sigue el principio de Liskov Substitution Principle (LSP) porque permite que cualquier clase derivada de <c>MoveSleep</c> (si la hubiera) 
            pueda sustituirse sin alterar el comportamiento de la lógica del juego.
            </summary>
            <param name="name">El nombre del movimiento.</param>
            <param name="attackValue">El valor de ataque del movimiento.</param>
        </member>
        <member name="M:ClassLibrary.MoveBurn.ExecuteMove(ClassLibrary.Pokemon,ClassLibrary.Pokemon,System.Double)">
             <summary>
             Método para aplicar el ataque del <c>IMove</c> en particular, considerando ambos pokemones.
             </summary>
             <param name="attacker">El pokemon que está atacando.</param>
             <param name="target">El pokemon que está siendo atacado.</param>
            
        </member>
        <member name="T:ClassLibrary.MoveNormal">
            <summary>
            La clase <c>NormalMove</c> tiene la responsabilidad de almacenar y gestionar los valores de ataque, su nombre, y método de ejecución de un movimiento común.
            Esto sigue el principio de responsabilidad única (SRP) ya que su única función es representar los atributos de un movimiento en el juego.
            </summary>
        </member>
        <member name="M:ClassLibrary.MoveNormal.ExecuteMove(ClassLibrary.Pokemon,ClassLibrary.Pokemon,System.Double)">
             <summary>
             Método para aplicar el ataque considerando ambos pokemones.
             </summary>
             <param name="attacker">El pokemon que está atacando.</param>
             <param name="target">El pokemon que está siendo atacado.</param>
            
        </member>
        <member name="T:ClassLibrary.MoveParalize">
            <summary>
            La clase <c>MoveParalize</c> tiene la responsabilidad de almacenar y gestionar los valores de ataque, su nombre, y método de ejecución de un movimiento especial.
            Esto sigue el principio de responsabilidad única (SRP) ya que su única función es representar los atributos de un movimiento en el juego.
            </summary>
            
        </member>
        <member name="M:ClassLibrary.MoveParalize.#ctor(System.String,System.Int32,System.Double)">
            <summary>
            Constructor de la clase <c>MoveParalize</c>. Inicializa los valores de nombre, ataque, defensa y curación.
            Esto sigue el principio de Liskov Substitution Principle (LSP) porque permite que cualquier clase derivada de <c>Move</c> (si la hubiera) 
            pueda sustituirse sin alterar el comportamiento de la lógica del juego.
            </summary>
            <param name="name">El nombre del movimiento.</param>
            <param name="attackValue">El valor de ataque del movimiento.</param>
        </member>
        <member name="M:ClassLibrary.MoveParalize.ExecuteMove(ClassLibrary.Pokemon,ClassLibrary.Pokemon,System.Double)">
             <summary>
             Método para aplicar el ataque del <c>IMove</c> en particular, considerando ambos pokemones.
             </summary>
             <param name="attacker">El pokemon que está atacando.</param>
             <param name="target">El pokemon que está siendo atacado.</param>
            
        </member>
        <member name="T:ClassLibrary.MovePoison">
            <summary>
            La clase <c>MovePoison</c> tiene la responsabilidad de almacenar y gestionar los valores de ataque, su nombre, y método de ejecución de un movimiento especial.
            Esto sigue el principio de responsabilidad única (SRP) ya que su única función es representar los atributos de un movimiento en el juego.
            </summary>
            
        </member>
        <member name="M:ClassLibrary.MovePoison.#ctor(System.String,System.Int32,System.Double)">
            <summary>
            Constructor de la clase <c>MovePoison</c>. Inicializa los valores de nombre, ataque, defensa y curación.
            Esto sigue el principio de Liskov Substitution Principle (LSP) porque permite que cualquier clase derivada de <c>MoveSleep</c> (si la hubiera) 
            pueda sustituirse sin alterar el comportamiento de la lógica del juego.
            </summary>
            <param name="name">El nombre del movimiento.</param>
            <param name="attackValue">El valor de ataque del movimiento.</param>
        </member>
        <member name="M:ClassLibrary.MovePoison.ExecuteMove(ClassLibrary.Pokemon,ClassLibrary.Pokemon,System.Double)">
             <summary>
             Método para aplicar el ataque del <c>IMove</c> en particular, considerando ambos pokemones.
             </summary>
             <param name="attacker">El pokemon que está atacando.</param>
             <param name="target">El pokemon que está siendo atacado.</param>
            
        </member>
        <member name="T:ClassLibrary.MoveSleep">
            <summary>
            La clase <c>MoveSleep</c> tiene la responsabilidad de almacenar y gestionar los valores de ataque, su nombre, y método de ejecución de un movimiento especial.
            Esto sigue el principio de responsabilidad única (SRP) ya que su única función es representar los atributos de un movimiento en el juego.
            </summary>
            
        </member>
        <member name="M:ClassLibrary.MoveSleep.#ctor(System.String,System.Int32,System.Double)">
            <summary>
            Constructor de la clase <c>MoveSleep</c>. Inicializa los valores de nombre, ataque, defensa y curación.
            Esto sigue el principio de Liskov Substitution Principle (LSP) porque permite que cualquier clase derivada de <c>MoveSleep</c> (si la hubiera) 
            pueda sustituirse sin alterar el comportamiento de la lógica del juego.
            </summary>
            <param name="name">El nombre del movimiento.</param>
            <param name="attackValue">El valor de ataque del movimiento.</param>
        </member>
        <member name="M:ClassLibrary.MoveSleep.ExecuteMove(ClassLibrary.Pokemon,ClassLibrary.Pokemon,System.Double)">
             <summary>
             Método para aplicar el ataque del <c>IMove</c> en particular, considerando ambos pokemones.
             </summary>
             <param name="attacker">El pokemon que está atacando.</param>
             <param name="target">El pokemon que está siendo atacado.</param>
            
        </member>
        <member name="T:ClassLibrary.Player">
            <summary>
            La clase  <c>Player</c> representa a un jugador en el juego, 
            responsable de gestionar los Pokémon disponibles, el Pokémon activo
            y el movimiento activo del jugador.
            </summary>
        </member>
        <member name="P:ClassLibrary.Player.DisplayName">
            <summary>               
            Obtiene el nombre para mostrar del jugador.
            </summary>
        </member>
        <member name="M:ClassLibrary.Player.#ctor(System.String)">
            <summary>
            Inicializa una nueva instancia de la clase Player con el nombre especificado.
            </summary>
            <param name="displayName">Nombre del jugador para mostrar en el juego.</param>
        </member>
        <member name="P:ClassLibrary.Player.AvailablePokemons">
            <summary>
            Lista de Pokémon disponibles para el jugador.
            </summary>
        </member>
        <member name="P:ClassLibrary.Player.ActivePokemon">
            <summary>
            El Pokémon activo del jugador.
            </summary>
        </member>
        <member name="P:ClassLibrary.Player.ActiveMove">
            <summary>
            El movimiento actualmente activo del Pokémon del jugador.
            </summary>
        </member>
        <member name="M:ClassLibrary.Player.SetOpponent(ClassLibrary.Player)">
            <summary>
            Establece al oponente del jugador.
            </summary>
            <param name="opponent">El jugador que será el oponente.</param>
        </member>
        <member name="M:ClassLibrary.Player.GetOpponent">
            <summary>
            Obtiene el oponente del jugador.
            </summary>
        </member>
        <member name="M:ClassLibrary.Player.AddPokemon(ClassLibrary.Pokemon)">
            <summary>
            Agrega un Pokémon a la lista de Pokémon disponibles para el jugador.
            </summary>
            <param name="pokemon">El Pokémon a agregar a la lista.</param>
        </member>
        <member name="M:ClassLibrary.Player.GetIndexOfPokemon(System.String)">
            <summary>
            Obtiene el índice de un Pokémon en la lista de Pokémon disponibles
            según su nombre para mostrar.
            </summary>
            <param name="pokemonDisplayName">Nombre del Pokémon a buscar.</param>
            <returns>Índice del Pokémon en la lista o -1 si no se encuentra.</returns>
        </member>
        <member name="M:ClassLibrary.Player.ActivatePokemon(System.Int32)">
            <summary>
            Activa un Pokémon de la lista disponible en base a su índice.
            </summary>
            <param name="index">Índice del Pokémon en la lista de disponibles.</param>
        </member>
        <member name="M:ClassLibrary.Player.GetIndexOfMoveInActivePokemon(System.String)">
            <summary>
            Obtiene el índice de un movimiento en el Pokémon activo 
            según el nombre del movimiento.
            </summary>
            <param name="moveDisplayName">Nombre del movimiento a buscar.</param>
            <returns>Índice del movimiento en la lista de movimientos del Pokémon activo o -1 si no se encuentra.</returns>
        </member>
        <member name="M:ClassLibrary.Player.ActivateMoveInActivePokemon(System.Int32)">
            <summary>
            Activa un movimiento en el Pokémon activo en base a su índice en la lista de movimientos.
            </summary>
            <param name="index">Índice del movimiento en la lista de movimientos del Pokémon activo.</param>
        </member>
        <member name="T:ClassLibrary.Pokemon">
            <summary>
            La clase  <c>Pokemon</c> es responsable de encapsular los atributos y comportamientos específicos de un Pokémon.
            Aplica el principio de responsabilidad única (SRP) al gestionar exclusivamente los datos y comportamientos de
            cada Pokémon. Utiliza el patrón Expert, ya que posee toda la información necesaria para administrar sus atributos,
            como puntos de vida y movimientos. Además facilita la extensión de la clase para añadir nuevas categorías de Pokémon
            o habilidades sin modificar la clase base, alineándose con el principio abierto/cerrado (OCP) y promoviendo una alta cohesión.
            Además la robustez y seguridad de esta clase se asegura al evitar estados inválidos y facilitar la detección de errores
            en el uso de la clase
            </summary>
        </member>
        <member name="M:ClassLibrary.Pokemon.#ctor">
            <summary>
            Inicializa una nueva instancia de la clase <see cref="T:ClassLibrary.Pokemon"/> con una lista de movimientos vacía.
            </summary>
        </member>
        <member name="P:ClassLibrary.Pokemon.IsPoisoned">
            <summary>
            Obtiene o establece si un Pokémon está envenenado.
            Si el Pokémon ya está envenenado, no puede ser afectado por otro estado (quemado, paralizado, dormido).
            </summary>
        </member>
        <member name="P:ClassLibrary.Pokemon.IsBurned">
            <summary>
            Obtiene o establece si un Pokémon está quemado.
            Si el Pokémon ya está quemado, no puede ser afectado por otro estado (envenenado, paralizado, dormido).
            </summary>
        </member>
        <member name="P:ClassLibrary.Pokemon.IsParalyzed">
            <summary>
            Obtiene o establece si un Pokémon está paralizado.
            Si el Pokémon ya está paralizado, no puede ser afectado por otro estado (envenenado, quemado, dormido).
            </summary>
        </member>
        <member name="P:ClassLibrary.Pokemon.SleepTurns">
            <summary>
            Obtiene o establece los turnos durante los cuales el Pokémon queda dormido.
            Si el Pokémon ya está envenenado, quemado o paralizado, no puede quedarse dormido.
            </summary>
        </member>
        <member name="P:ClassLibrary.Pokemon.Name">
            <summary>
            Obtiene o establece el nombre del Pokémon.
            </summary>
            <exception cref="T:System.ArgumentNullException">Se lanza si el nombre es nulo o vacío.</exception>
        </member>
        <member name="P:ClassLibrary.Pokemon.HealthPoints">
            <summary>
            Obtiene o establece los puntos de salud del Pokémon.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">Se lanza si los puntos de salud son negativos.</exception>
        </member>
        <member name="P:ClassLibrary.Pokemon.SpecialMoveNormal">
            <summary>
            Obtiene o establece el movimiento especial del Pokémon.
            </summary>
            <exception cref="T:System.ArgumentNullException">Se lanza si el movimiento especial es nulo.</exception>
        </member>
        <member name="P:ClassLibrary.Pokemon.Type">
            <summary>
            Obtiene o establece el tipo del Pokémon.
            </summary>
        </member>
        <member name="P:ClassLibrary.Pokemon.Moves">
            <summary>
            Obtiene o establece la lista de movimientos regulares del Pokémon.
            </summary>
        </member>
        <member name="M:ClassLibrary.Pokemon.TryAttack">
            <summary>
            Verifica si el <c>Pokemon</c>  puede atacar.
            </summary>
        </member>
        <member name="T:ClassLibrary.PokemonCatalog">
            <summary>
            La clase  <c>PokemonCatalog</c> se encarga de gestionar el acceso y la manipulación de un catálogo de Pokémon, siguiendo
            el Principio de Responsabilidad Única (SRP), lo que significa que se especializa exclusivamente en la gestión de
            datos de los Pokémon. Esto asegura que cualquier modificación en la forma de almacenar o buscar Pokémon se realice
            centralizadamente en esta clase, minimizando el impacto en el resto del sistema. Además, al aplicar el patrón
            Expert de GRASP, PokemonCatalog se convierte en la autoridad en la gestión del catálogo, lo que facilita la
            incorporación de nuevas características, como métodos de búsqueda adicionales o cambios en la fuente de datos,
            sin necesidad de alteraciones significativas en otras partes del código. Esta separación de responsabilidades no
            solo optimiza el mantenimiento y la extensibilidad, sino que también reduce las razones de cambio, permitiendo una
            evolución más ágil y segura del sistema.
            </summary>
        </member>
        <member name="M:ClassLibrary.PokemonCatalog.FindPokemonByName(System.String)">
            <summary>
            Encuentra un Pokémon por su nombre en el catálogo.
            Recorre la lista de Pokémon y devuelve el objeto correspondiente si encuentra una coincidencia.
            Si no encuentra el Pokémon, retorna null.
            </summary>
            <param name="pokemonName">Nombre del Pokémon a buscar.</param>
            <returns>El objeto Pokemon si se encuentra, de lo contrario null.</returns>
        </member>
        <member name="T:ClassLibrary.PokemonCatalogBuilder">
            <summary>
            La clase  <c>PokemonCatalogBuilder</c> se encarga de crear y configurar un catálogo de Pokémon, gestionando la asignación
            de atributos y movimientos. Aplica el Principio de Responsabilidad Única (SRP) al centralizar toda la lógica
            de construcción, lo que facilita el mantenimiento. Como patrón de diseño, se puede considerar un Builder, ya que
            permite crear objetos complejos de manera controlada. Además, utiliza el patrón Expert de GRASP, siendo la autoridad
            en la creación de Pokémon, lo que asegura una implementación coherente. Cumple con el Principio de Sustitución de
            Liskov (LSP), permitiendo su extensión sin afectar al catálogo. Esta estructura promueve un diseño desacoplado y escalable,
            facilitando la integración de nuevas funcionalidades en el sistema.
            </summary>
        </member>
        <member name="M:ClassLibrary.PokemonCatalogBuilder.#ctor">
            <summary>
            Constructor de la clase que inicializa y añade varios Pokémon al catálogo.
            </summary>
        </member>
        <member name="M:ClassLibrary.PokemonCatalogBuilder.AddPokemonToCatalog(System.String,System.Collections.Generic.List{ClassLibrary.Move},ClassLibrary.PokemonType.Type)">
            <summary>
            Método privado que añade un Pokémon al catálogo, asignando su nombre, lista de movimientos y movimiento especial.
            </summary>
            <param name="name">Nombre del Pokémon.</param>
            <param name="moves">Lista de movimientos del Pokémon.</param>
            <param name="specialNormalMove">Movimiento especial del Pokémon.</param>
            <param name="type">El tipo del Pokémon.</param>
        </member>
        <member name="M:ClassLibrary.PokemonCatalogBuilder.GetPokemonList">
            <summary>
            Devuelve la lista de todos los Pokémon creados en el catálogo.
            </summary>
            <returns>Lista de Pokémon.</returns>
        </member>
        <member name="T:ClassLibrary.PokemonType">
            <summary>
            La clase <c>PokemonType</c> es responsable de gestionar los tipos de Pokémon y su efectividad en combates.
            Aplica el principio de responsabilidad única (SRP) al enfocarse exclusivamente en la lógica de tipos y 
            efectividad de ataques entre tipos.
            Utiliza el patrón Expert, ya que posee toda la información necesaria para determinar la efectividad de los ataques
            entre tipos, promoviendo alta cohesión y bajo acoplamiento con otras clases.
            Además, sigue el principio abierto/cerrado (OCP), permitiendo agregar nuevos tipos o combinaciones de efectividad
            sin modificar la estructura de la clase.
            La robustez y seguridad de esta clase se aseguran al validar la existencia de combinaciones de tipos y evitar
            estados inválidos, facilitando la detección y manejo de errores en el uso de esta clase.
            </summary>
        </member>
        <member name="T:ClassLibrary.PokemonType.Type">
            <summary>
            Enumeración que define los tipos de Pokémon.
            </summary>
        </member>
        <member name="M:ClassLibrary.PokemonType.GetEffectiveness(ClassLibrary.PokemonType.Type,ClassLibrary.PokemonType.Type)">
            <summary>
            Método que devuelve la efectividad entre tipos.
            </summary>
            <param name="defendingType">Tipo del Pokémon atacante.</param>
            <param name="attackingType">Tipo del Pokémon defensor.</param>
            <returns>
            El multiplicador de daño según la efectividad entre tipos. 
            Devuelve 1.0 si no hay ventaja o desventaja.
            </returns>
        </member>
        <member name="T:ClassLibrary.Turn">
            <summary>
            Esta clase conoce las especificaciones del turno de un jugador actual con sus correspondientes ataques.
            </summary>
        </member>
        <member name="F:ClassLibrary.Turn.CurrentPlayer">
            <summary>
            Jugador que está actualmente en turno.
            </summary>
        </member>
        <member name="F:ClassLibrary.Turn.WaitingPlayer">
            <summary>
            Jugador que está esperando su turno.
            </summary>
        </member>
        <member name="M:ClassLibrary.Turn.#ctor(ClassLibrary.Player,ClassLibrary.Player)">
            <summary>
            Inicializa una nueva instancia de la clase <see cref="T:ClassLibrary.Turn"/> con dos jugadores.
            </summary>
            <remarks>
            <see cref="T:ClassLibrary.Player"/> es la clase que representa a un jugador en el juego.
            </remarks>
        </member>
        <member name="M:ClassLibrary.Turn.ChangeTurn">
            <summary>
            Cambia el turno entre el jugador actual y el jugador en espera.
            </summary>
        </member>
        <member name="M:ClassLibrary.Turn.PenalizeTurn(ClassLibrary.Player)">
            <summary>
            Penaliza el turno de un jugador. Si el jugador penalizado es el actual, se cambia el turno.
            </summary>
            <remarks>
            Se debe validar que el parámetro no sea nulo antes de usarlo.
            </remarks>
        </member>
        <member name="M:ClassLibrary.Turn.PlayerAttack(ClassLibrary.Pokemon,ClassLibrary.Pokemon,ClassLibrary.Move)">
            <summary>
            Permite que un jugador ataque a otro Pokémon usando un movimiento.
            </summary>
            <remarks>
            Se debe validar que move, attacker y defender no sean nulos antes de usar.
            </remarks>
        </member>
        <member name="M:ClassLibrary.Turn.GetEffectivenessMessage(System.Double)">
            <summary>
            Obtiene un mensaje sobre la efectividad del ataque.
            </summary>
            <returns>Un mensaje que describe la efectividad.</returns>
        </member>
        <member name="T:ClassLibrary.UserInterface">
            <summary>
            La clase <c>UserInterface</c> es responsable de construir y devolver mensajes 
            formateados para la interfaz de usuario, proporcionando la información necesaria sobre
            el juego, para interactuar con el usuario en el chatbot.
            - Principio de Responsabilidad Única (SRP): La clase se encarga exclusivamente de generar y mostrar mensajes
            que se utilizan para informar al usuario sobre el estado del juego, manteniéndose concentrada en
            esta responsabilidad sin realizar ninguna lógica del juego.
            - Expert Pattern (GRASP): Esta clase es la "experta" en formatear y construir mensajes para la interfaz de
            usuario, ya que es la única que conoce el formato y contenido de los mensajes que se deben mostrar.
            </summary>
        </member>
        <member name="M:ClassLibrary.UserInterface.ShowMessagePokemonCatalog">
            <summary>
            Genera un mensaje con el catálogo de todos los Pokémon disponibles.
            </summary>
            <returns>Una cadena con el catálogo de nombres de Pokémon.</returns>
        </member>
        <member name="M:ClassLibrary.UserInterface.ShowMessageToAddPokemons(System.Int32)">
            <summary>
            Genera un mensaje indicando el número del Pokémon a seleccionar o informa que ya se han seleccionado los 6 Pokémon.
            </summary>
            <param name="currentSelection">El índice actual de selección de Pokémon.</param>
            <returns>Un mensaje indicando el número de selección de Pokémon o que ya se completó la selección.</returns>
        </member>
        <member name="M:ClassLibrary.UserInterface.ShowMessageSelectedPokemons(System.Collections.Generic.List{ClassLibrary.Pokemon})">
            <summary>
            Genera un mensaje con la lista de Pokémon seleccionados por el jugador.
            </summary>
            <param name="selectedPokemons">Lista de Pokémon seleccionados.</param>
            <returns>Un mensaje con los nombres de los Pokémon seleccionados.</returns>
        </member>
        <member name="M:ClassLibrary.UserInterface.ShowMessagePokemonHealth(System.Collections.Generic.List{ClassLibrary.Pokemon},System.Collections.Generic.List{ClassLibrary.Pokemon})">
            <summary>
            Genera un mensaje con la información de salud de los Pokémon del jugador y del oponente.
            </summary>
            <param name="playerPokemons">Lista de Pokémon del jugador.</param>
            <param name="opponentPokemons">Lista de Pokémon del oponente.</param>
            <returns>Una cadena con la información de salud de los Pokémon.</returns>
            <exception cref="T:System.ArgumentNullException">Se lanza si alguna de las listas es nula.</exception>
        </member>
        <member name="M:ClassLibrary.UserInterface.ShowMessageChangePokemon(System.String,System.String)">
            <summary>
            Genera un mensaje indicando que el jugador ha cambiado su Pokémon activo y ha perdido su turno.
            </summary>
            <param name="playerDisplayName">Nombre del jugador que realizó el cambio de Pokémon.</param>
            <param name="newPokemonName">Nombre del nuevo Pokémon activado.</param>
            <returns>Mensaje formateado indicando el cambio de Pokémon y la pérdida de turno.</returns>
        </member>
        <member name="M:ClassLibrary.UserInterface.ShowMessageNoPlayersWaiting">
            <summary>
            Genera un mensaje indicando que no hay jugadores en la lista de espera.
            </summary>
            <returns>Mensaje indicando que no hay nadie esperando.</returns>
        </member>
        <member name="M:ClassLibrary.UserInterface.ShowMessagePlayersWaiting(System.Collections.ObjectModel.ReadOnlyCollection{ClassLibrary.Player})">
            <summary>
            Genera un mensaje listando los nombres de los jugadores en la lista de espera.
            </summary>
            <param name="waitingPlayers">Lista de jugadores en espera.</param>
            <returns>Un mensaje con los nombres de los jugadores en espera.</returns>
        </member>
        <member name="M:ClassLibrary.UserInterface.ShowMessageAttackOcurred(ClassLibrary.Pokemon,ClassLibrary.Pokemon,ClassLibrary.Player,ClassLibrary.Player)">
            <summary>
            Muestra un mensaje indicando que un ataque ha ocurrido, con detalles sobre el atacante, el defensor y el movimiento usado.
            </summary>
            <param name="attackingPokemon">El Pokémon que está atacando.</param>
            <param name="defendingPokemon">El Pokémon que está siendo atacado.</param>
            <param name="attacker">El jugador que controla al Pokémon atacante.</param>
            <param name="defender">El jugador que controla al Pokémon defensor.</param>
            <returns>Un mensaje formateado indicando que el ataque ocurrió.</returns>
        </member>
        <member name="M:ClassLibrary.UserInterface.ShowMessageAttackDidNotOccur(ClassLibrary.Player,ClassLibrary.Pokemon)">
            <summary>
            Muestra un mensaje indicando que el ataque no ocurrió, debido a que el Pokémon del jugador tiene un ataque especial activo que lo impide.
            </summary>
            <param name="attacker">El jugador que intenta realizar el ataque.</param>
            <param name="attackingPokemon">El Pokémon que está intentando atacar.</param>
            <returns>Un mensaje formateado indicando que el ataque no ocurrió debido a un movimiento especial activo.</returns>
        </member>
        <member name="T:ClassLibrary.WaitingList">
            <summary>
            La clase <c>WaitingList</c> es responsable de gestionar la lista de jugadores en espera para jugar.
            Aplica el principio de responsabilidad única (SRP) al enfocarse exclusivamente en las operaciones
            relacionadas con la lista de espera de jugadores, como agregar, remover y buscar.
            Utiliza el patrón Expert, ya que posee toda la información necesaria para manejar la lista
            de jugadores de manera eficiente, promoviendo una alta cohesión.
            Además, está diseñada para ser extensible en el futuro, siguiendo el principio abierto/cerrado (OCP),
            permitiendo, por ejemplo, la selección de un jugador aleatorio sin modificar la estructura básica.
            La clase mantiene su robustez y seguridad al validar las entradas y evitar estados inválidos.
            </summary>
        </member>
        <member name="M:ClassLibrary.WaitingList.AddPlayer(System.String)">
            <summary>
            Agrega un jugador a la lista de espera.
            </summary>
            <param name="DisplayName">El nombre de usuario de Discord en el servidor
            del bot a agregar.
            </param>
            <returns><c>true</c> si se agrega el usuario; <c>false</c> en caso
            contrario.</returns>
        </member>
        <member name="M:ClassLibrary.WaitingList.RemovePlayer(System.String)">
            <summary>
            Remueve un jugador de la lista de espera.
            </summary>
            <param name="DisplayName">El nombre de usuario de Discord en el servidor
            del bot a remover.
            </param>
            <returns><c>true</c> si se remueve el usuario; <c>false</c> en caso
            contrario.</returns>
        </member>
        <member name="M:ClassLibrary.WaitingList.FindPlayerByDisplayName(System.String)">
            <summary>
            Busca un jugador por el nombre de usuario de Discord en el servidor del
            bot.
            </summary>
            <param name="DisplayName">El nombre de usuario de Discord en el servidor
            del bot a buscar.
            </param>
            <returns>El jugador encontrado o <c>null</c> en caso contrario.
            </returns>
        </member>
        <member name="M:ClassLibrary.WaitingList.GetAnyoneWaiting">
            <summary>
            Retorna un jugador cualquiera esperando para jugar. En esta
            implementación provista no es cualquiera, sino el primero. En la
            implementación definitiva, debería ser uno aleatorio.
            
            </summary>
            <returns></returns>
        </member>
    </members>
</doc>
